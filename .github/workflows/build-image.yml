name: Build Amazon Linux 2023 Golden Image

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS region'
        required: false
        default: 'us-east-1'
        type: string
      iam_instance_profile:
        description: 'IAM instance profile name for SSM (optional - Packer can create temporary one)'
        required: false
        default: ''
        type: string
  push:
    branches:
      - aws-packer
    paths:
      - '*.pkr.hcl'
      - '.github/workflows/**'
  pull_request:
    branches:
      - aws-packer

env:
  PKR_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  PKR_VAR_iam_instance_profile: ${{ vars.IAM_INSTANCE_PROFILE || github.event.inputs.iam_instance_profile || '' }}
  PKR_VAR_vpc_id: ${{ vars.VPC_ID || '' }}
  PKR_VAR_subnet_id: ${{ vars.SUBNET_ID || '' }}
  PKR_VAR_cis_s3_bucket: ${{ vars.CIS_S3_BUCKET || '' }}
  PKR_VAR_cis_s3_prefix: ${{ vars.CIS_S3_PREFIX || 'cis-tools' }}
  PKR_VAR_enable_cis_hardening: ${{ vars.ENABLE_CIS_HARDENING || 'true' }}

jobs:
  validate:
    name: Validate Packer Template
    runs-on: terraform
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

      - name: Install cpio from local RPM (CRITICAL)
        run: |
          echo "=== Installing cpio from local RPM file ==="
          
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio is already available: $(cpio --version | head -1)"
            exit 0
          fi
          
          if ! ls rpm/cpio-*.rpm 1> /dev/null 2>&1; then
            echo "❌ ERROR: cpio RPM not found in rpm/ directory"
            exit 1
          fi
          
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          echo "Found cpio RPM: $CPIO_RPM_FILE"
          
          echo "Converting RPM to CPIO archive..."
          rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
          
          if [ ! -s /tmp/cpio_archive.cpio ]; then
            echo "❌ Failed to create CPIO archive"
            exit 1
          fi
          
          echo "CPIO archive created: $(ls -lh /tmp/cpio_archive.cpio | awk '{print $5}')"
          
          echo "Extracting CPIO archive with Python..."
          EXTRACT_DIR=$(mktemp -d)
          
          # Create Python extraction script
          cat > /tmp/extract_cpio.py <<'PYTHON_SCRIPT_END'
          import sys
          import os
          
          cpio_file = sys.argv[1]
          extract_dir = sys.argv[2]
          
          def parse_cpio(data):
              pos = 0
              files = 0
              
              while pos < len(data):
                  if pos + 110 > len(data):
                      break
                  
                  magic = data[pos:pos+6]
                  if magic not in [b'070701', b'070702']:
                      if pos == 0:
                          print(f"Invalid CPIO magic at start: {magic}")
                      break
                  
                  try:
                      header = data[pos:pos+110].decode('ascii')
                      namesize = int(header[94:102], 16)
                      filesize = int(header[54:62], 16)
                  except Exception as e:
                      print(f"Header parse error: {e}")
                      break
                  
                  name_start = pos + 110
                  name_end = name_start + namesize
                  if name_end > len(data):
                      break
                  
                  filename = data[name_start:name_end-1].decode('utf-8', errors='ignore')
                  
                  if filename == 'TRAILER!!!':
                      break
                  
                  name_end_aligned = ((name_end + 3) // 4) * 4
                  file_data_start = name_end_aligned
                  file_data_end = file_data_start + filesize
                  
                  if file_data_end > len(data):
                      break
                  
                  if filesize > 0 and filename and not filename.endswith('/'):
                      filepath = os.path.join(extract_dir, filename.lstrip('./'))
                      os.makedirs(os.path.dirname(filepath), exist_ok=True)
                      with open(filepath, 'wb') as f:
                          f.write(data[file_data_start:file_data_end])
                      files += 1
                      if files <= 3:
                          print(f"  Extracted: {filename}")
                  
                  file_data_end_aligned = ((file_data_end + 3) // 4) * 4
                  pos = file_data_end_aligned
              
              return files
          
          try:
              with open(cpio_file, 'rb') as f:
                  data = f.read()
              
              print(f"CPIO archive size: {len(data)} bytes")
              files = parse_cpio(data)
              
              if files > 0:
                  print(f"✅ Successfully extracted {files} files")
                  sys.exit(0)
              else:
                  print("❌ No files extracted")
                  sys.exit(1)
          except Exception as e:
              print(f"❌ Error: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          PYTHON_SCRIPT_END
          
          python3 /tmp/extract_cpio.py /tmp/cpio_archive.cpio "$EXTRACT_DIR"
          
          if [ $? -ne 0 ]; then
            echo "❌ Failed to extract CPIO archive"
            rm -f /tmp/cpio_archive.cpio /tmp/extract_cpio.py
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          rm -f /tmp/cpio_archive.cpio /tmp/extract_cpio.py
          
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Looking for cpio in alternative locations..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -name "cpio" -type f -executable | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio binary not found in extracted files"
            echo "Contents of extract directory:"
            find "$EXTRACT_DIR" -type f | head -30
            exit 1
          fi
          
          echo "Found cpio binary: $CPIO_BINARY"
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          
          if ~/bin/cpio --version; then
            echo "✅ cpio installed successfully to ~/bin"
          else
            echo "❌ cpio installation failed"
            exit 1
          fi
          
          rm -rf "$EXTRACT_DIR"

      - name: Verify dependencies
        run: |
          echo "=== Verification ==="
          command -v cpio && echo "✅ cpio: $(cpio --version | head -1)" || { echo "❌ cpio: MISSING"; exit 1; }

      - name: Setup Packer
        run: |
          PACKER_VERSION="1.10.0"
          if command -v packer >/dev/null 2>&1; then
            echo "✅ Packer already installed"
            packer version
            exit 0
          fi
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/
            rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer
          packer version

      - name: Clear AWS credential caches
        run: rm -rf ~/.aws/cli/cache ~/.aws/sso/cache ~/.aws/credentials ~/.aws/config 2>/dev/null || true

      - name: Configure AWS Credentials
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "ERROR: AWS credentials not configured"
            exit 1
          fi
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Validate Packer template
        run: packer validate aws-golden-image.pkr.hcl

  build:
    name: Build AMI
    needs: validate
    runs-on: terraform
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install cpio from local RPM
        run: |
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio already installed"
            cpio --version | head -1
            exit 0
          fi
          
          echo "Installing cpio from RPM..."
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          
          if [ -z "$CPIO_RPM_FILE" ]; then
            echo "❌ cpio RPM not found"
            exit 1
          fi
          
          rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
          EXTRACT_DIR=$(mktemp -d)
          
          cat > /tmp/ex.py <<'PYE'
          import sys,os
          c,e=sys.argv[1],sys.argv[2]
          def p(d):
            pos=0;f=0
            while pos<len(d):
              if pos+110>len(d):break
              if d[pos:pos+6] not in [b'070701',b'070702']:break
              try:h=d[pos:pos+110].decode('ascii');ns=int(h[94:102],16);fs=int(h[54:62],16)
              except:break
              ne=pos+110+ns
              if ne>len(d):break
              fn=d[pos+110:ne-1].decode('utf-8',errors='ignore')
              if fn=='TRAILER!!!':break
              na=((ne+3)//4)*4;fde=na+fs
              if fde>len(d):break
              if fs>0 and fn and not fn.endswith('/'):
                fp=os.path.join(e,fn.lstrip('./'));os.makedirs(os.path.dirname(fp),exist_ok=True)
                with open(fp,'wb') as ff:ff.write(d[na:fde])
                f+=1
              pos=((fde+3)//4)*4
            return f
          with open(c,'rb') as ff:d=ff.read()
          print(f"Extracted {p(d)} files");sys.exit(0)
          PYE
          
          python3 /tmp/ex.py /tmp/cpio_archive.cpio "$EXTRACT_DIR"
          EXTRACT_EXIT=$?
          rm -f /tmp/cpio_archive.cpio /tmp/ex.py
          
          if [ $EXTRACT_EXIT -ne 0 ]; then
            echo "❌ Extraction failed"
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          # Look for cpio binary - don't require executable bit as it may not be set yet
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/usr/bin/cpio" -type f | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Trying alternative path..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Trying name-based search..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -name "cpio" -type f | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio binary not found in extracted files"
            echo "Extract directory contents:"
            find "$EXTRACT_DIR" -type f | head -20
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          echo "Found cpio: $CPIO_BINARY"
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          
          if ~/bin/cpio --version; then
            echo "✅ cpio installed successfully"
          else
            echo "❌ cpio installation verification failed"
            exit 1
          fi
          
          rm -rf "$EXTRACT_DIR"

      - name: Setup Packer
        run: |
          PACKER_VERSION="1.10.0"
          if command -v packer >/dev/null 2>&1; then packer version; exit 0; fi
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/; rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer; packer version

      - name: Configure AWS Credentials
        run: |
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Install AWS Session Manager Plugin
        run: |
          if command -v session-manager-plugin >/dev/null 2>&1; then session-manager-plugin --version; exit 0; fi
          LOCAL_RPM="rpm/session-manager-plugin.rpm"
          EXTRACT_DIR=$(mktemp -d); cd "$EXTRACT_DIR"
          rpm2cpio "$OLDPWD/$LOCAL_RPM" | cpio -idmv 2>&1 | head -10
          BINARY=$(find . -name "session-manager-plugin" -type f | head -1)
          cp "$BINARY" ~/bin/session-manager-plugin
          chmod +x ~/bin/session-manager-plugin
          ~/bin/session-manager-plugin --version
          rm -rf "$EXTRACT_DIR"

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Build Packer image
        run: |
          PACKER_BUILD_CMD="packer build -var=\"aws_region=${{ env.PKR_VAR_aws_region }}\""
          [ -n "${{ env.PKR_VAR_iam_instance_profile }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"iam_instance_profile=${{ env.PKR_VAR_iam_instance_profile }}\""
          [ -n "${{ env.PKR_VAR_vpc_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"vpc_id=${{ env.PKR_VAR_vpc_id }}\""
          [ -n "${{ env.PKR_VAR_subnet_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"subnet_id=${{ env.PKR_VAR_subnet_id }}\""
          [ -n "${{ env.PKR_VAR_cis_s3_bucket }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"cis_s3_bucket=${{ env.PKR_VAR_cis_s3_bucket }}\""
          [ -n "${{ env.PKR_VAR_cis_s3_prefix }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"cis_s3_prefix=${{ env.PKR_VAR_cis_s3_prefix }}\""
          [ -n "${{ env.PKR_VAR_enable_cis_hardening }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"enable_cis_hardening=${{ env.PKR_VAR_enable_cis_hardening }}\""
          SECURITY_GROUP_IDS="${{ vars.SECURITY_GROUP_IDS }}"
          if [ -n "$SECURITY_GROUP_IDS" ]; then
            SG_HCL=$(echo "$SECURITY_GROUP_IDS" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            VAR_FILE=$(mktemp --suffix=.hcl)
            echo "security_group_ids = $SG_HCL" > "$VAR_FILE"
            PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var-file=$VAR_FILE"
          fi
          PACKER_BUILD_CMD="${PACKER_BUILD_CMD} aws-golden-image.pkr.hcl"
          eval $PACKER_BUILD_CMD

      - name: Output AMI ID
        if: success()
        run: echo "✅ AMI build completed successfully!"
name: Build Amazon Linux 2023 Golden Image

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS region'
        required: false
        default: 'us-east-1'
        type: string
      iam_instance_profile:
        description: 'IAM instance profile name for SSM (optional - Packer can create temporary one)'
        required: false
        default: ''
        type: string
  push:
    branches:
      - aws-packer-cis
    paths:
      - '*.pkr.hcl'
      - '.github/workflows/**'
  pull_request:
    branches:
      - aws-packer-cis

env:
  PKR_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  PKR_VAR_iam_instance_profile: ${{ vars.IAM_INSTANCE_PROFILE || github.event.inputs.iam_instance_profile || '' }}
  PKR_VAR_vpc_id: ${{ vars.VPC_ID || '' }}
  PKR_VAR_subnet_id: ${{ vars.SUBNET_ID || '' }}
  PKR_VAR_cis_s3_bucket: ${{ vars.CIS_S3_BUCKET || '' }}
  PKR_VAR_cis_s3_prefix: ${{ vars.CIS_S3_PREFIX || 'cis-tools' }}
  PKR_VAR_enable_cis_hardening: ${{ vars.ENABLE_CIS_HARDENING || 'true' }}
  PACKER_VERSION: ${{ vars.PACKER_VERSION || '1.14.3' }}

jobs:
  validate:
    name: Validate Packer Template
    runs-on: terraform
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

      - name: Install cpio from local RPM (CRITICAL)
        run: |
          echo "=== Installing cpio from local RPM file ==="
          
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio is already available: $(cpio --version | head -1)"
            exit 0
          fi
          
          if ! ls rpm/cpio-*.rpm 1> /dev/null 2>&1; then
            echo "❌ ERROR: cpio RPM not found in rpm/ directory"
            exit 1
          fi
          
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          echo "Found cpio RPM: $CPIO_RPM_FILE"
          
          echo "Converting RPM to CPIO archive..."
          rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
          
          if [ ! -s /tmp/cpio_archive.cpio ]; then
            echo "❌ Failed to create CPIO archive"
            exit 1
          fi
          
          echo "CPIO archive created: $(ls -lh /tmp/cpio_archive.cpio | awk '{print $5}')"
          
          echo "Extracting CPIO archive with Python..."
          EXTRACT_DIR=$(mktemp -d)
          
          # Create Python extraction script
          cat > /tmp/extract_cpio.py <<'PYTHON_SCRIPT_END'
          import sys
          import os
          
          cpio_file = sys.argv[1]
          extract_dir = sys.argv[2]
          
          def parse_cpio(data):
              pos = 0
              files = 0
              
              while pos < len(data):
                  if pos + 110 > len(data):
                      break
                  
                  magic = data[pos:pos+6]
                  if magic not in [b'070701', b'070702']:
                      if pos == 0:
                          print(f"Invalid CPIO magic at start: {magic}")
                      break
                  
                  try:
                      header = data[pos:pos+110].decode('ascii')
                      namesize = int(header[94:102], 16)
                      filesize = int(header[54:62], 16)
                  except Exception as e:
                      print(f"Header parse error: {e}")
                      break
                  
                  name_start = pos + 110
                  name_end = name_start + namesize
                  if name_end > len(data):
                      break
                  
                  filename = data[name_start:name_end-1].decode('utf-8', errors='ignore')
                  
                  if filename == 'TRAILER!!!':
                      break
                  
                  name_end_aligned = ((name_end + 3) // 4) * 4
                  file_data_start = name_end_aligned
                  file_data_end = file_data_start + filesize
                  
                  if file_data_end > len(data):
                      break
                  
                  if filesize > 0 and filename and not filename.endswith('/'):
                      filepath = os.path.join(extract_dir, filename.lstrip('./'))
                      os.makedirs(os.path.dirname(filepath), exist_ok=True)
                      with open(filepath, 'wb') as f:
                          f.write(data[file_data_start:file_data_end])
                      files += 1
                      if files <= 3:
                          print(f"  Extracted: {filename}")
                  
                  file_data_end_aligned = ((file_data_end + 3) // 4) * 4
                  pos = file_data_end_aligned
              
              return files
          
          try:
              with open(cpio_file, 'rb') as f:
                  data = f.read()
              
              print(f"CPIO archive size: {len(data)} bytes")
              files = parse_cpio(data)
              
              if files > 0:
                  print(f"✅ Successfully extracted {files} files")
                  sys.exit(0)
              else:
                  print("❌ No files extracted")
                  sys.exit(1)
          except Exception as e:
              print(f"❌ Error: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          PYTHON_SCRIPT_END
          
          python3 /tmp/extract_cpio.py /tmp/cpio_archive.cpio "$EXTRACT_DIR"
          
          if [ $? -ne 0 ]; then
            echo "❌ Failed to extract CPIO archive"
            rm -f /tmp/cpio_archive.cpio /tmp/extract_cpio.py
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          rm -f /tmp/cpio_archive.cpio /tmp/extract_cpio.py
          
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Looking for cpio in alternative locations..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -name "cpio" -type f -executable | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio binary not found in extracted files"
            echo "Contents of extract directory:"
            find "$EXTRACT_DIR" -type f | head -30
            exit 1
          fi
          
          echo "Found cpio binary: $CPIO_BINARY"
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          
          if ~/bin/cpio --version; then
            echo "✅ cpio installed successfully to ~/bin"
          else
            echo "❌ cpio installation failed"
            exit 1
          fi
          
          rm -rf "$EXTRACT_DIR"

      - name: Verify dependencies
        run: |
          echo "=== Verification ==="
          command -v cpio && echo "✅ cpio: $(cpio --version | head -1)" || { echo "❌ cpio: MISSING"; exit 1; }

      - name: Setup Packer
        run: |
          PACKER_VERSION="${PACKER_VERSION:-1.14.3}"
          if command -v packer >/dev/null 2>&1; then
            INSTALLED_VERSION=$(packer version | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ "$INSTALLED_VERSION" = "$PACKER_VERSION" ]; then
              echo "✅ Packer ${PACKER_VERSION} already installed"
              packer version
              exit 0
            else
              echo "⚠️  Packer ${INSTALLED_VERSION} installed, but ${PACKER_VERSION} required. Reinstalling..."
            fi
          fi
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            echo "Downloading Packer ${PACKER_VERSION}..."
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/
            rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer
          packer version

      - name: Clear AWS credential caches
        run: rm -rf ~/.aws/cli/cache ~/.aws/sso/cache ~/.aws/credentials ~/.aws/config 2>/dev/null || true

      - name: Configure AWS Credentials
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "ERROR: AWS credentials not configured"
            exit 1
          fi
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Validate Packer template
        run: packer validate aws-golden-image.pkr.hcl

  build:
    name: Build AMI
    needs: validate
    runs-on: terraform
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    permissions:
      contents: read
    outputs:
      ami_id: ${{ steps.build_ami.outputs.AMI_ID }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install cpio from local RPM
        run: |
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio already installed"
            cpio --version | head -1
            exit 0
          fi
          
          echo "Installing cpio from RPM..."
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          
          if [ -z "$CPIO_RPM_FILE" ]; then
            echo "❌ cpio RPM not found"
            exit 1
          fi
          
          rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
          EXTRACT_DIR=$(mktemp -d)
          
          cat > /tmp/ex.py <<'PYE'
          import sys,os
          c,e=sys.argv[1],sys.argv[2]
          def p(d):
            pos=0;f=0
            while pos<len(d):
              if pos+110>len(d):break
              if d[pos:pos+6] not in [b'070701',b'070702']:break
              try:h=d[pos:pos+110].decode('ascii');ns=int(h[94:102],16);fs=int(h[54:62],16)
              except:break
              ne=pos+110+ns
              if ne>len(d):break
              fn=d[pos+110:ne-1].decode('utf-8',errors='ignore')
              if fn=='TRAILER!!!':break
              na=((ne+3)//4)*4;fde=na+fs
              if fde>len(d):break
              if fs>0 and fn and not fn.endswith('/'):
                fp=os.path.join(e,fn.lstrip('./'));os.makedirs(os.path.dirname(fp),exist_ok=True)
                with open(fp,'wb') as ff:ff.write(d[na:fde])
                f+=1
              pos=((fde+3)//4)*4
            return f
          with open(c,'rb') as ff:d=ff.read()
          print(f"Extracted {p(d)} files");sys.exit(0)
          PYE
          
          python3 /tmp/ex.py /tmp/cpio_archive.cpio "$EXTRACT_DIR"
          EXTRACT_EXIT=$?
          rm -f /tmp/cpio_archive.cpio /tmp/ex.py
          
          if [ $EXTRACT_EXIT -ne 0 ]; then
            echo "❌ Extraction failed"
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          # Look for cpio binary - don't require executable bit as it may not be set yet
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/usr/bin/cpio" -type f | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Trying alternative path..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "Trying name-based search..."
            CPIO_BINARY=$(find "$EXTRACT_DIR" -name "cpio" -type f | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio binary not found in extracted files"
            echo "Extract directory contents:"
            find "$EXTRACT_DIR" -type f | head -20
            rm -rf "$EXTRACT_DIR"
            exit 1
          fi
          
          echo "Found cpio: $CPIO_BINARY"
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          
          if ~/bin/cpio --version; then
            echo "✅ cpio installed successfully"
          else
            echo "❌ cpio installation verification failed"
            exit 1
          fi
          
          rm -rf "$EXTRACT_DIR"

      - name: Setup Packer
        run: |
          PACKER_VERSION="${PACKER_VERSION:-1.14.3}"
          if command -v packer >/dev/null 2>&1; then
            INSTALLED_VERSION=$(packer version | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ "$INSTALLED_VERSION" = "$PACKER_VERSION" ]; then
              echo "✅ Packer ${PACKER_VERSION} already installed"
              packer version
              exit 0
            else
              echo "⚠️  Packer ${INSTALLED_VERSION} installed, but ${PACKER_VERSION} required. Reinstalling..."
            fi
          fi
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            echo "Downloading Packer ${PACKER_VERSION}..."
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/; rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer; packer version

      - name: Configure AWS Credentials
        run: |
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Install AWS Session Manager Plugin
        run: |
          if command -v session-manager-plugin >/dev/null 2>&1; then session-manager-plugin --version; exit 0; fi
          LOCAL_RPM="rpm/session-manager-plugin.rpm"
          EXTRACT_DIR=$(mktemp -d); cd "$EXTRACT_DIR"
          rpm2cpio "$OLDPWD/$LOCAL_RPM" | cpio -idmv 2>&1 | head -10
          BINARY=$(find . -name "session-manager-plugin" -type f | head -1)
          cp "$BINARY" ~/bin/session-manager-plugin
          chmod +x ~/bin/session-manager-plugin
          ~/bin/session-manager-plugin --version
          rm -rf "$EXTRACT_DIR"

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Build Packer image
        id: build_ami
        run: |
          PACKER_OUTPUT_FILE=$(mktemp)
          PACKER_BUILD_CMD="packer build -var=\"aws_region=${{ env.PKR_VAR_aws_region }}\""
          [ -n "${{ env.PKR_VAR_iam_instance_profile }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"iam_instance_profile=${{ env.PKR_VAR_iam_instance_profile }}\""
          [ -n "${{ env.PKR_VAR_vpc_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"vpc_id=${{ env.PKR_VAR_vpc_id }}\""
          [ -n "${{ env.PKR_VAR_subnet_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"subnet_id=${{ env.PKR_VAR_subnet_id }}\""
          [ -n "${{ env.PKR_VAR_cis_s3_bucket }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"cis_s3_bucket=${{ env.PKR_VAR_cis_s3_bucket }}\""
          [ -n "${{ env.PKR_VAR_cis_s3_prefix }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"cis_s3_prefix=${{ env.PKR_VAR_cis_s3_prefix }}\""
          [ -n "${{ env.PKR_VAR_enable_cis_hardening }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"enable_cis_hardening=${{ env.PKR_VAR_enable_cis_hardening }}\""
          SECURITY_GROUP_IDS="${{ vars.SECURITY_GROUP_IDS }}"
          if [ -n "$SECURITY_GROUP_IDS" ]; then
            SG_HCL=$(echo "$SECURITY_GROUP_IDS" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            VAR_FILE=$(mktemp --suffix=.hcl)
            echo "security_group_ids = $SG_HCL" > "$VAR_FILE"
            PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var-file=$VAR_FILE"
          fi
          PACKER_BUILD_CMD="${PACKER_BUILD_CMD} aws-golden-image.pkr.hcl"
          
          # Run Packer build and capture output
          eval $PACKER_BUILD_CMD 2>&1 | tee "$PACKER_OUTPUT_FILE"
          PACKER_EXIT=${PIPESTATUS[0]}
          
          # Extract AMI ID from output
          AMI_ID=$(grep -oE 'ami-[0-9a-f]{17}' "$PACKER_OUTPUT_FILE" | tail -1)
          if [ -z "$AMI_ID" ]; then
            AMI_ID=$(grep -oE 'ami-[0-9a-f]{8,17}' "$PACKER_OUTPUT_FILE" | tail -1)
          fi
          
          if [ -z "$AMI_ID" ]; then
            echo "❌ ERROR: Could not extract AMI ID from Packer output"
            echo "Last 50 lines of Packer output:"
            tail -50 "$PACKER_OUTPUT_FILE"
            rm -f "$PACKER_OUTPUT_FILE"
            exit 1
          fi
          
          # Verify AMI exists
          if aws ec2 describe-images --image-ids "$AMI_ID" --region "${{ env.PKR_VAR_aws_region }}" >/dev/null 2>&1; then
            echo "AMI_ID=$AMI_ID" >> $GITHUB_OUTPUT
            echo "Built AMI: $AMI_ID"
          else
            echo "❌ ERROR: AMI $AMI_ID does not exist in region ${{ env.PKR_VAR_aws_region }}"
            rm -f "$PACKER_OUTPUT_FILE"
            exit 1
          fi
          
          rm -f "$PACKER_OUTPUT_FILE"
          
          # Exit with Packer's exit code
          exit $PACKER_EXIT
      
      - name: Output AMI ID
        if: success()
        run: |
          echo "AMI build completed successfully!"
          echo "AMI ID: ${{ steps.build_ami.outputs.AMI_ID }}"

  cis-assessment:
    name: CIS Compliance Assessment
    needs: build
    runs-on: terraform
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        run: |
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Install AWS CLI and Session Manager Plugin
        run: |
          mkdir -p ~/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          
          # Install AWS CLI if not present
          if ! command -v aws >/dev/null 2>&1; then
            if [ -f "rpm/awscli-exe-linux-x86_64.zip" ]; then
              unzip -q rpm/awscli-exe-linux-x86_64.zip -d /tmp
              /tmp/aws/install -i ~/aws-cli -b ~/bin
            else
              curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscliv2.zip
              unzip -q /tmp/awscliv2.zip -d /tmp
              /tmp/aws/install -i ~/aws-cli -b ~/bin
              rm -f /tmp/awscliv2.zip
            fi
          fi
          
          # Install Session Manager Plugin if not present
          if ! command -v session-manager-plugin >/dev/null 2>&1; then
            if [ -f "rpm/session-manager-plugin.rpm" ]; then
              EXTRACT_DIR=$(mktemp -d)
              cd "$EXTRACT_DIR"
              rpm2cpio "$OLDPWD/rpm/session-manager-plugin.rpm" | cpio -idmv 2>&1 | head -10
              BINARY=$(find . -name "session-manager-plugin" -type f | head -1)
              cp "$BINARY" ~/bin/session-manager-plugin
              chmod +x ~/bin/session-manager-plugin
              rm -rf "$EXTRACT_DIR"
            fi
          fi
          
          aws --version
          session-manager-plugin --version || echo "Session Manager Plugin installed"

      - name: Launch EC2 Instance for Assessment
        id: launch_instance
        run: |
          AMI_ID="${{ needs.build.outputs.ami_id }}"
          VPC_ID="${{ env.PKR_VAR_vpc_id }}"
          SUBNET_ID="${{ env.PKR_VAR_subnet_id }}"
          IAM_PROFILE="${{ env.PKR_VAR_iam_instance_profile }}"
          SECURITY_GROUP_IDS="${{ vars.SECURITY_GROUP_IDS }}"
          
          if [ -z "$AMI_ID" ]; then
            echo "❌ ERROR: AMI ID not found from build job"
            exit 1
          fi
          
          if [ -z "$VPC_ID" ] || [ -z "$SUBNET_ID" ]; then
            echo "❌ ERROR: VPC_ID and SUBNET_ID must be set for CIS assessment"
            exit 1
          fi
          
          # Use first security group if multiple provided
          if [ -n "$SECURITY_GROUP_IDS" ]; then
            SG_ID=$(echo "$SECURITY_GROUP_IDS" | cut -d',' -f1 | tr -d ' ')
          else
            echo "❌ ERROR: SECURITY_GROUP_IDS must be set"
            exit 1
          fi
          
          echo "Launching EC2 instance for CIS assessment..."
          echo "AMI: $AMI_ID"
          echo "Subnet: $SUBNET_ID"
          echo "Security Group: $SG_ID"
          
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id "$AMI_ID" \
            --instance-type t3.micro \
            --subnet-id "$SUBNET_ID" \
            --security-group-ids "$SG_ID" \
            --iam-instance-profile Name="$IAM_PROFILE" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=cis-assessment-$(date +%s)},{Key=Purpose,Value=CIS-Compliance-Assessment}]" \
            --query 'Instances[0].InstanceId' \
            --output text \
            --region "${{ env.PKR_VAR_aws_region }}")
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "❌ ERROR: Failed to launch EC2 instance"
            exit 1
          fi
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "✅ Launched instance: $INSTANCE_ID"
          
          # Wait for instance to be running
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID" --region "${{ env.PKR_VAR_aws_region }}"
          
          # Wait for SSM agent to be ready
          echo "Waiting for SSM agent to be ready..."
          for i in {1..30}; do
            if aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$INSTANCE_ID" --region "${{ env.PKR_VAR_aws_region }}" --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null | grep -q "Online"; then
              echo "✅ SSM agent is ready"
              break
            fi
            echo "Waiting for SSM agent... ($i/30)"
            sleep 10
          done

      - name: Download CIS Assessment Scripts
        run: |
          mkdir -p scripts/cis
          # Scripts should already be in repo, but ensure they're executable
          chmod +x scripts/cis/*.sh 2>/dev/null || true

      - name: Run CIS Assessment
        run: |
          INSTANCE_ID="${{ steps.launch_instance.outputs.INSTANCE_ID }}"
          CIS_S3_BUCKET="${{ env.PKR_VAR_cis_s3_bucket }}"
          CIS_S3_PREFIX="${{ env.PKR_VAR_cis_s3_prefix }}"
          
          echo "=== Running CIS Assessment on Instance $INSTANCE_ID ==="
          
          # Upload assessment script to instance
          echo "Uploading assessment script..."
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'export CIS_S3_BUCKET=\"$CIS_S3_BUCKET\"',
              'export CIS_S3_PREFIX=\"$CIS_S3_PREFIX\"',
              'export ENABLE_CIS_HARDENING=true',
              'export AWS_REGION=${{ env.PKR_VAR_aws_region }}',
              'bash -s'
            ]" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'Command.CommandId' \
            --output text > /tmp/command_id.txt
          
          COMMAND_ID=$(cat /tmp/command_id.txt)
          
          # Send the script content via stdin
          cat scripts/cis/download-cis-tools.sh scripts/cis/run-cis-assessment.sh | \
            aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=[$(cat scripts/cis/download-cis-tools.sh scripts/cis/run-cis-assessment.sh | sed "s/'/'\"'\"'/g" | sed "s/^/'/;s/$/'/")]" \
              --region "${{ env.PKR_VAR_aws_region }}" \
              --query 'Command.CommandId' \
              --output text
          
          # Better approach: Use SSM document with script file
          echo "Running CIS assessment via SSM..."
          
          # Create temporary script file
          ASSESSMENT_SCRIPT=$(mktemp)
          cat > "$ASSESSMENT_SCRIPT" << 'ASSESS_EOF'
          #!/bin/bash
          export CIS_S3_BUCKET="${CIS_S3_BUCKET}"
          export CIS_S3_PREFIX="${CIS_S3_PREFIX}"
          export ENABLE_CIS_HARDENING=true
          export AWS_REGION="${AWS_REGION}"
          
          # Download CIS tools
          bash scripts/cis/download-cis-tools.sh
          
          # Run assessment
          bash scripts/cis/run-cis-assessment.sh
          ASSESS_EOF
          
          # Actually, let's use a simpler approach - run commands directly
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'export CIS_S3_BUCKET=\"$CIS_S3_BUCKET\"',
              'export CIS_S3_PREFIX=\"$CIS_S3_PREFIX\"',
              'export ENABLE_CIS_HARDENING=true',
              'export AWS_REGION=${{ env.PKR_VAR_aws_region }}',
              'cd /tmp',
              'aws s3 sync s3://$CIS_S3_BUCKET/$CIS_S3_PREFIX/ /tmp/cis-tools/ --region ${{ env.PKR_VAR_aws_region }} || true',
              'chmod +x /tmp/cis-tools/*.sh 2>/dev/null || true',
              'if [ -f /tmp/cis-tools/run-cis-assessment.sh ]; then bash /tmp/cis-tools/run-cis-assessment.sh; else echo \"Assessment script not found in S3\"; fi'
            ]" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          echo "Waiting for command to complete..."
          
          # Wait for command to complete (max 30 minutes)
          for i in {1..180}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "${{ env.PKR_VAR_aws_region }}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "InProgress")
            
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Command completed with status: $STATUS"
              break
            fi
            echo "Command status: $STATUS ($i/180)"
            sleep 10
          done
          
          # Get command output
          echo "=== CIS Assessment Output ==="
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'StandardOutputContent' \
            --output text
          
          echo ""
          echo "=== CIS Assessment Errors (if any) ==="
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'StandardErrorContent' \
            --output text
          
          # Check exit code
          EXIT_CODE=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'ResponseCode' \
            --output text)
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "⚠️  CIS Assessment completed with exit code: $EXIT_CODE"
            echo "This may indicate compliance issues. Review the assessment output above."
          else
            echo "✅ CIS Assessment completed successfully"
          fi

      - name: Download Assessment Reports
        if: always()
        run: |
          INSTANCE_ID="${{ steps.launch_instance.outputs.INSTANCE_ID }}"
          
          echo "Downloading assessment reports from instance..."
          
          # Download reports via SSM
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'if [ -d /var/log/cis-assessment ]; then tar czf /tmp/cis-reports.tar.gz -C /var/log/cis-assessment .; echo \"Reports archived\"; else echo \"No assessment reports found\"; fi'
            ]" \
            --region "${{ env.PKR_VAR_aws_region }}" \
            --query 'Command.CommandId' \
            --output text > /tmp/report_cmd_id.txt
          
          REPORT_CMD_ID=$(cat /tmp/report_cmd_id.txt)
          sleep 5
          
          # Get the archive and download it
          # Note: This is simplified - in practice you might want to upload reports to S3 instead
          echo "Assessment reports would be available at /var/log/cis-assessment on the instance"
          echo "To download manually: aws ssm start-session --target $INSTANCE_ID"

      - name: Terminate Assessment Instance
        if: always()
        run: |
          INSTANCE_ID="${{ steps.launch_instance.outputs.INSTANCE_ID }}"
          
          if [ -n "$INSTANCE_ID" ]; then
            echo "Terminating assessment instance: $INSTANCE_ID"
            aws ec2 terminate-instances \
              --instance-ids "$INSTANCE_ID" \
              --region "${{ env.PKR_VAR_aws_region }}" \
              --query 'TerminatingInstances[0].CurrentState.Name' \
              --output text
            echo "✅ Instance termination initiated"
          fi
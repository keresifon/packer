name: Build Amazon Linux 2023 Golden Image

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS region'
        required: false
        default: 'us-east-1'
        type: string
      iam_instance_profile:
        description: 'IAM instance profile name for SSM (optional - Packer can create temporary one)'
        required: false
        default: ''
        type: string
  push:
    branches:
      - main
    paths:
      - '*.pkr.hcl'
      - '.github/workflows/**'
  pull_request:
    branches:
      - main

env:
  PKR_VAR_aws_region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  PKR_VAR_iam_instance_profile: ${{ vars.IAM_INSTANCE_PROFILE || github.event.inputs.iam_instance_profile || '' }}
  PKR_VAR_vpc_id: ${{ vars.VPC_ID || '' }}
  PKR_VAR_subnet_id: ${{ vars.SUBNET_ID || '' }}

jobs:
  validate:
    name: Validate Packer Template
    runs-on: terraform
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

      - name: Install cpio from local RPM (CRITICAL)
        run: |
          echo "=== Installing cpio from local RPM file ==="
          
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio is already available: $(cpio --version | head -1)"
            exit 0
          fi
          
          if ! ls rpm/cpio-*.rpm 1> /dev/null 2>&1; then
            echo "❌ ERROR: cpio RPM not found in rpm/ directory"
            echo "Please add: rpm/cpio-*.rpm to your repository"
            exit 1
          fi
          
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          echo "Found cpio RPM: $CPIO_RPM_FILE"
          
          # Check if rpm2cpio is available (it usually is on RHEL)
          if command -v rpm2cpio >/dev/null 2>&1; then
            echo "✅ rpm2cpio is available, but we need cpio to extract..."
            echo "Using Python to extract the CPIO archive from rpm2cpio output..."
            
            EXTRACT_DIR=$(mktemp -d)
            
            # rpm2cpio outputs a CPIO archive, we'll extract it with Python
            rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
            
            python3 - /tmp/cpio_archive.cpio "$EXTRACT_DIR" << 'PYTHON_SCRIPT'
import sys
import os
import struct

cpio_file = sys.argv[1]
extract_dir = sys.argv[2]

def parse_cpio(data):
    """Parse CPIO new ASCII format (070701)"""
    pos = 0
    files_extracted = 0
    
    while pos < len(data):
        # Check for magic number
        if pos + 110 > len(data):
            break
            
        magic = data[pos:pos+6]
        if magic != b'070701' and magic != b'070702':
            if pos == 0:
                print(f"Invalid CPIO magic: {magic}")
            break
        
        # Parse header (110 bytes for newc format)
        try:
            header = data[pos:pos+110].decode('ascii')
            namesize = int(header[94:102], 16)
            filesize = int(header[54:62], 16)
        except:
            break
        
        # Get filename
        name_start = pos + 110
        name_end = name_start + namesize
        if name_end > len(data):
            break
            
        filename = data[name_start:name_end-1].decode('utf-8', errors='ignore')
        
        # Check for trailer
        if filename == 'TRAILER!!!':
            break
        
        # Calculate file data position (aligned to 4 bytes)
        name_end_aligned = ((name_end + 3) // 4) * 4
        file_data_start = name_end_aligned
        file_data_end = file_data_start + filesize
        
        if file_data_end > len(data):
            break
        
        # Extract file
        if filesize > 0 and filename and not filename.endswith('/'):
            filepath = os.path.join(extract_dir, filename.lstrip('./'))
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            with open(filepath, 'wb') as f:
                f.write(data[file_data_start:file_data_end])
            
            files_extracted += 1
            if files_extracted <= 5:
                print(f"  Extracted: {filename}")
        
        # Move to next entry (aligned to 4 bytes)
        file_data_end_aligned = ((file_data_end + 3) // 4) * 4
        pos = file_data_end_aligned
    
    return files_extracted

try:
    with open(cpio_file, 'rb') as f:
        data = f.read()
    
    print(f"CPIO archive size: {len(data)} bytes")
    files = parse_cpio(data)
    
    if files > 0:
        print(f"✅ Successfully extracted {files} files")
        sys.exit(0)
    else:
        print("❌ No files extracted")
        sys.exit(1)
        
except Exception as e:
    print(f"❌ Error: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
PYTHON_SCRIPT
            
            if [ $? -eq 0 ]; then
              echo "✅ CPIO archive extracted successfully"
            else
              echo "❌ Failed to extract CPIO archive"
              rm -f /tmp/cpio_archive.cpio
              rm -rf "$EXTRACT_DIR"
              exit 1
            fi
            
            rm -f /tmp/cpio_archive.cpio
            
          else
            echo "❌ rpm2cpio not available - cannot extract RPM"
            exit 1
          fi
          
          # Find cpio binary
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            CPIO_BINARY=$(find "$EXTRACT_DIR" -name "cpio" -type f -executable | head -1)
          fi
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio binary not found in extracted files"
            echo "Searching for any executables:"
            find "$EXTRACT_DIR" -type f -executable | head -20
            exit 1
          fi
          
          echo "Found cpio: $CPIO_BINARY"
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          
          ~/bin/cpio --version
          echo "✅ cpio installed to ~/bin"
          
          rm -rf "$EXTRACT_DIR"

      - name: Verify dependencies
        run: |
          echo "=== Verification ==="
          command -v cpio && echo "✅ cpio: $(cpio --version | head -1)" || { echo "❌ cpio: MISSING"; exit 1; }
          command -v curl && echo "✅ curl: available" || echo "⚠️  curl: not available"
          command -v unzip && echo "✅ unzip: available" || echo "⚠️  unzip: not available"
          command -v tar && echo "✅ tar: available" || echo "⚠️  tar: not available"
          command -v rpm2cpio && echo "✅ rpm2cpio: available" || echo "⚠️  rpm2cpio: not available"

      - name: Setup Packer
        run: |
          PACKER_VERSION="1.10.0"
          
          if command -v packer >/dev/null 2>&1; then
            echo "✅ Packer already installed"
            packer version
            exit 0
          fi
          
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/
            rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer
          packer version

      - name: Clear AWS credential caches
        run: |
          rm -rf ~/.aws/cli/cache ~/.aws/sso/cache ~/.aws/credentials ~/.aws/config 2>/dev/null || true

      - name: Configure AWS Credentials
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "ERROR: AWS credentials not configured"
            exit 1
          fi
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Validate Packer template
        run: packer validate aws-golden-image.pkr.hcl

  build:
    name: Build AMI
    needs: validate
    runs-on: terraform
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup user bin directory
        run: |
          mkdir -p ~/bin ~/.local/bin
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

      - name: Install cpio from local RPM (CRITICAL)
        run: |
          echo "=== Installing cpio from local RPM file ==="
          
          if command -v cpio >/dev/null 2>&1; then
            echo "✅ cpio is already available"
            cpio --version | head -1
            exit 0
          fi
          
          CPIO_RPM_FILE=$(ls rpm/cpio-*.rpm 2>/dev/null | head -1)
          if [ -z "$CPIO_RPM_FILE" ]; then
            echo "❌ ERROR: cpio RPM not found"
            exit 1
          fi
          
          echo "Found: $CPIO_RPM_FILE"
          EXTRACT_DIR=$(mktemp -d)
          
          # Use rpm2cpio to convert RPM to CPIO, then extract with Python
          rpm2cpio "$CPIO_RPM_FILE" > /tmp/cpio_archive.cpio
          
          python3 - /tmp/cpio_archive.cpio "$EXTRACT_DIR" << 'PYTHON_SCRIPT'
import sys
import os

cpio_file = sys.argv[1]
extract_dir = sys.argv[2]

def parse_cpio(data):
    pos = 0
    files = 0
    
    while pos < len(data):
        if pos + 110 > len(data):
            break
        
        magic = data[pos:pos+6]
        if magic not in [b'070701', b'070702']:
            break
        
        try:
            header = data[pos:pos+110].decode('ascii')
            namesize = int(header[94:102], 16)
            filesize = int(header[54:62], 16)
        except:
            break
        
        name_start = pos + 110
        name_end = name_start + namesize
        if name_end > len(data):
            break
        
        filename = data[name_start:name_end-1].decode('utf-8', errors='ignore')
        
        if filename == 'TRAILER!!!':
            break
        
        name_end_aligned = ((name_end + 3) // 4) * 4
        file_data_start = name_end_aligned
        file_data_end = file_data_start + filesize
        
        if file_data_end > len(data):
            break
        
        if filesize > 0 and filename and not filename.endswith('/'):
            filepath = os.path.join(extract_dir, filename.lstrip('./'))
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            with open(filepath, 'wb') as f:
                f.write(data[file_data_start:file_data_end])
            files += 1
        
        file_data_end_aligned = ((file_data_end + 3) // 4) * 4
        pos = file_data_end_aligned
    
    return files

try:
    with open(cpio_file, 'rb') as f:
        data = f.read()
    
    files = parse_cpio(data)
    print(f"Extracted {files} files")
    sys.exit(0 if files > 0 else 1)
except Exception as e:
    print(f"Error: {e}")
    sys.exit(1)
PYTHON_SCRIPT
          
          if [ $? -ne 0 ]; then
            echo "❌ Extraction failed"
            exit 1
          fi
          
          rm -f /tmp/cpio_archive.cpio
          
          CPIO_BINARY=$(find "$EXTRACT_DIR" -path "*/bin/cpio" -type f -o -name "cpio" -type f -executable | head -1)
          
          if [ -z "$CPIO_BINARY" ]; then
            echo "❌ cpio not found"
            exit 1
          fi
          
          cp "$CPIO_BINARY" ~/bin/cpio
          chmod +x ~/bin/cpio
          ~/bin/cpio --version
          rm -rf "$EXTRACT_DIR"

      - name: Setup Packer
        run: |
          PACKER_VERSION="1.10.0"
          if command -v packer >/dev/null 2>&1; then
            packer version
            exit 0
          fi
          
          if [ -f "bin/packer_${PACKER_VERSION}_linux_amd64.zip" ]; then
            unzip -q "bin/packer_${PACKER_VERSION}_linux_amd64.zip" -d ~/bin/
          else
            curl -fsSL "https://releases.hashicorp.com/packer/${PACKER_VERSION}/packer_${PACKER_VERSION}_linux_amd64.zip" -o /tmp/packer.zip
            unzip -q /tmp/packer.zip -d ~/bin/
            rm /tmp/packer.zip
          fi
          chmod +x ~/bin/packer
          packer version

      - name: Clear AWS credential caches
        run: |
          rm -rf ~/.aws/cli/cache ~/.aws/sso/cache ~/.aws/credentials ~/.aws/config 2>/dev/null || true

      - name: Configure AWS Credentials
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "ERROR: AWS credentials not configured"
            exit 1
          fi
          ACCESS_KEY=$(echo "${{ secrets.AWS_ACCESS_KEY_ID }}" | xargs)
          SECRET_KEY=$(echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | xargs)
          SESSION_TOKEN=$(echo "${{ secrets.AWS_SESSION_TOKEN }}" | xargs)
          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          [ -n "${SESSION_TOKEN}" ] && echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.PKR_VAR_aws_region }}" >> $GITHUB_ENV

      - name: Install AWS Session Manager Plugin
        run: |
          if command -v session-manager-plugin >/dev/null 2>&1; then
            session-manager-plugin --version
            exit 0
          fi
          
          LOCAL_RPM="rpm/session-manager-plugin.rpm"
          if [ ! -f "$LOCAL_RPM" ]; then
            echo "❌ $LOCAL_RPM not found"
            exit 1
          fi
          
          EXTRACT_DIR=$(mktemp -d)
          cd "$EXTRACT_DIR"
          rpm2cpio "$OLDPWD/$LOCAL_RPM" | cpio -idmv 2>&1 | head -10
          
          BINARY=$(find . -name "session-manager-plugin" -type f | head -1)
          if [ -z "$BINARY" ]; then
            echo "❌ Binary not found"
            exit 1
          fi
          
          cp "$BINARY" ~/bin/session-manager-plugin
          chmod +x ~/bin/session-manager-plugin
          ~/bin/session-manager-plugin --version
          rm -rf "$EXTRACT_DIR"

      - name: Initialize Packer
        run: packer init aws-golden-image.pkr.hcl

      - name: Build Packer image
        run: |
          PACKER_BUILD_CMD="packer build -var=\"aws_region=${{ env.PKR_VAR_aws_region }}\""
          [ -n "${{ env.PKR_VAR_iam_instance_profile }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"iam_instance_profile=${{ env.PKR_VAR_iam_instance_profile }}\""
          [ -n "${{ env.PKR_VAR_vpc_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"vpc_id=${{ env.PKR_VAR_vpc_id }}\""
          [ -n "${{ env.PKR_VAR_subnet_id }}" ] && PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var=\"subnet_id=${{ env.PKR_VAR_subnet_id }}\""
          
          SECURITY_GROUP_IDS="${{ vars.SECURITY_GROUP_IDS }}"
          if [ -n "$SECURITY_GROUP_IDS" ]; then
            SG_HCL=$(echo "$SECURITY_GROUP_IDS" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            VAR_FILE=$(mktemp --suffix=.hcl)
            echo "security_group_ids = $SG_HCL" > "$VAR_FILE"
            PACKER_BUILD_CMD="${PACKER_BUILD_CMD} -var-file=$VAR_FILE"
          fi
          
          PACKER_BUILD_CMD="${PACKER_BUILD_CMD} aws-golden-image.pkr.hcl"
          eval $PACKER_BUILD_CMD

      - name: Output AMI ID
        if: success()
        run: echo "✅ AMI build completed successfully!"